/**
 * 
 */
package uk.co.alvagem.projectview.kanban;

import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.GridLayout;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DragGestureEvent;
import java.awt.dnd.DragGestureListener;
import java.awt.dnd.DragSource;
import java.awt.dnd.DropTarget;
import java.awt.dnd.DropTargetDragEvent;
import java.awt.dnd.DropTargetDropEvent;
import java.awt.dnd.DropTargetEvent;
import java.awt.dnd.DropTargetListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.JInternalFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.Border;
import javax.swing.border.TitledBorder;

import uk.co.alvagem.database.DAOFactory;
import uk.co.alvagem.projectview.dao.TaskDAO;
import uk.co.alvagem.projectview.model.Task;
import uk.co.alvagem.projectview.model.TaskStatus;
import uk.co.alvagem.projectview.swingui.Main;
import uk.co.alvagem.projectview.swingui.ProjectsExplorer;
import uk.co.alvagem.projectview.swingui.TaskEditor;
import uk.co.alvagem.swingui.ExceptionDisplay;

/**
 * @author bruce_porteous
 *
 */
public class KanbanView extends JInternalFrame {
    private Main app;
	private static final long serialVersionUID = 1L;
	private ArrayList<Column> columns = new ArrayList<>();
	private Map<Object,Tile> taskTiles = new HashMap<>();

	/**
	 * 
	 */
	public KanbanView( Main app) {
		this.app = app;
		setResizable(true);
		setMaximizable(true);
		setIconifiable(true);
		setClosable(true);

		// default with magic numbers
		setSize(500,300);   // magic
		setLocation(20,20); // magic

		TaskStatus[] statusValues = TaskStatus.values();
		GridLayout layout = new GridLayout(1,statusValues.length);
		setLayout(layout);

		
		for(TaskStatus status : statusValues) {
			Column column = new Column(status);
			add(column);
			columns.add(column);
		}
	}

    Main getApp(){
        return app;
    }

	public void setRootTask(Task rootTask) {
		setTitle(rootTask.getName());
		addChildTasks(rootTask);
	}

	/**
	 * Recursively adds all the child tasks to the board.
	 * @param task
	 */
	private void addChildTasks(Task task) {
		for(Task t : task.getSubTasks()) {
			if(t.getSubTasks().isEmpty()) {
				Column c = columns.get(t.getStatus().ordinal()); 
				Tile tile = new Tile(c, t);
				c.add(tile); 
				taskTiles.put(keyOfTask(t), tile);
			} else {
				addChildTasks(t);
			}
		}

	}
	public Object keyOfTask(Task t) {
		String key = "task:" + t.getId();
		return key;
	}

	public Tile tileFromKey(Object key) {
		return taskTiles.get(key);
	}
	

	
	private class Column extends JPanel {

		private static final long serialVersionUID = 1L;
		private TaskStatus columnStatus;
		

		Column(TaskStatus status) {
			columnStatus = status;
			Border blackline = BorderFactory.createLineBorder(Color.black);
			TitledBorder title = BorderFactory.createTitledBorder(blackline, status.getName());
			title.setTitleJustification(TitledBorder.CENTER);
			setBorder(title);

			setLayout(new BoxLayout(this, BoxLayout.PAGE_AXIS));
			//panel.setTransferHandler(new PanelTransferHandler());

			DropTargetListener listener = new DropTargetListener() {

				@Override
				public void dragEnter(DropTargetDragEvent dtde) {
				}

				@Override
				public void dragOver(DropTargetDragEvent dtde) {
				}

				@Override
				public void dropActionChanged(DropTargetDragEvent dtde) {
				}

				@Override
				public void dragExit(DropTargetEvent dte) {
				}

				@Override
				public void drop(DropTargetDropEvent dtde) {
					System.out.println(dtde.getSource());
					try {
						Object key =  dtde.getTransferable().getTransferData(TransferableTile.TILE_FLAVOR);
						// Key is the string that identifies the task. (generated by getTransferData)
						Tile source = tileFromKey(key);
						source.moveToColumn(Column.this);

						// TODO - update task status.

					} catch (UnsupportedFlavorException | IOException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}

					// this gets fired on the drop.
					dtde.dropComplete(true);	
				}

			};
			DropTarget dt = new DropTarget(this, listener);
			dt.setActive(true);
		}
	}
	
	private class Tile extends JLabel  {
		private static final long serialVersionUID = 1L;
		private final Task task;
		private Column column;

		Tile(Column column, final Task task) {
			assert(task != null);
			this.column = column;
			this.task = task;
			setText(task.getName());
			setToolTipText(task.getDescription());

			setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY, 2));
			//			TileTransferHandler handler = new TileTransferHandler();
			//			setTransferHandler(handler);

			DragGestureListener listener = new DragGestureListener() {

				@Override
				public void dragGestureRecognized(DragGestureEvent dge) {
					Cursor cursor = Cursor.getDefaultCursor();

					if (dge.getDragAction() == DnDConstants.ACTION_MOVE) {

						cursor = DragSource.DefaultCopyDrop;
					}
					Transferable t = new TransferableTile(Tile.this);
					dge.startDrag(cursor, t);
				}

			};

			DragSource ds = new DragSource();
			ds.createDefaultDragGestureRecognizer(this,
					DnDConstants.ACTION_MOVE, listener);

	        MouseListener ml = new MouseAdapter() {
	            public void mousePressed(MouseEvent e) {
                    if (e.getClickCount() == 2) {
                    	try {

                    		TaskEditor.editTask(KanbanView.this, Tile.this.task);
                        } catch (Exception ex){
                        	new ExceptionDisplay(getApp().getCommandFrame(),getApp().getAppTitle(),ex); 
                        }
                    }
	            }
	        };
	        addMouseListener(ml);


		}

		
		void moveToColumn(Column newColumn) {
			column.remove(this);
			newColumn.add(this);
			column.revalidate();
			column.repaint();
			newColumn.revalidate();
			
			updateStatus(newColumn.columnStatus);
			
			column = newColumn;
		}
		
		private void updateStatus(TaskStatus status) {
	        DAOFactory factory = DAOFactory.instance(DAOFactory.HIBERNATE);
            factory.beginTransaction();
            TaskDAO dao = factory.getTaskDAO();
            try {
                dao.makePersistent(task);
                task.getHistory().size();
                task.setStatus(status);
                task.commitHistory();
                factory.commit();
            } catch (Exception e) {
                factory.rollback();
                throw e;
            }
		}
	}

	/**
	 * allows the tile itself to be transferred via Drag and Drop.
	 * @author bruce_porteous
	 *
	 */
	static class TransferableTile implements Transferable {

		public final static DataFlavor TILE_FLAVOR = new DataFlavor(Tile.class, "Tile");
		private final static DataFlavor[] flavors = new DataFlavor[1];
		static {
			flavors[0] = TILE_FLAVOR;
		}

		private Tile tile; // the tile being transferred (via DnD)

		TransferableTile(Tile tile){
			this.tile = tile;
		}

		@Override
		public DataFlavor[] getTransferDataFlavors() {
			return flavors;
		}

		@Override
		public boolean isDataFlavorSupported(DataFlavor flavor) {
			return flavor.equals(flavors[0]);
		}

		@Override
		public Object getTransferData(DataFlavor flavor)
				throws UnsupportedFlavorException, IOException {
			if(!isDataFlavorSupported(flavor)) {
				throw new UnsupportedFlavorException(flavor);
			}
			String key = "task:" + tile.task.getId();
			return key;
		}

	};

}
